  <title>ASCII Art Tetris</title>
  <style>
    body {
      font-family: monospace;
      text-align: center;
      background: #000;
      color: #fff;
      margin: 0;
      padding: 20px;
      overflow: hidden;
      height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #gameCanvas {
      background: #000;
      margin: 20px auto;
      display: block;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='400' height='400' viewBox='0 0 400 400'%3E%3Crect width='400' height='400' fill='black'/%3E%3Cg filter='url(%23blur)'%3E%3Crect x='50' y='50' width='100' height='50' fill='rgba(255,0,0,0.5)'/%3E%3Crect x='200' y='100' width='150' height='75' fill='rgba(0,0,255,0.5)'/%3E%3Crect x='100' y='200' width='125' height='60' fill='rgba(255,255,0,0.5)'/%3E%3Crect x='250' y='250' width='80' height='90' fill='rgba(255,255,255,0.3)'/%3E%3C/g%3E%3Cdefs%3E%3Cfilter id='blur'%3E%3CfeGaussianBlur stdDeviation='5'/%3E%3C/filter%3E%3C/defs%3E%3C/svg%3E");
      background-repeat: repeat;
      background-size: 200px 200px;
    }
    .piece {
      color: #0f0;
    }
    #game-over {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #222;
      padding: 20px;
      border: 2px solid #f00;
      color: #f00;
      font-size: 24px;
      display: none;
      z-index: 100;
    }
    #controls {
      position: fixed;
      bottom: 20px;
      left: 0;
      right: 0;
      display: flex;
      justify-content: space-between;
      pointer-events: none;
    }
    .control-column {
      display: flex;
      flex-direction: column;
      gap: 10px;
      pointer-events: all;
    }
    .control-btn {
      background: #444;
      color: #fff;
      border: 2px solid #777;
      border-radius: 5px;
      padding: 15px;
      font-size: 20px;
      touch-action: none;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 60px;
      height: 60px;
    }
    .control-btn svg {
      width: 100%;
      height: 100%;
    }
    #instructions {
      margin-top: 20px;
      font-size: 16px;
      color: #888;
      overflow-y: auto; 
      max-height: calc(100vh - 500px);
    }
    #instructions h2 {
      color: #fff;
      margin-bottom: 10px;
    }
    #instructions p {
      margin: 5px 0;
    }
  </style>
</head>
<body>
  <h1>ASCII Tetris</h1>
  <canvas id="gameCanvas"></canvas>
  <div id="game-over">GAME OVER!</div>
  <div id="controls">
    <div class="control-column" style="margin-left: 20px;">
      <button class="control-btn" id="left">
        <svg viewBox="0 0 24 24">
          <path fill="currentColor" d="M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6 1.41-1.41z"/>
        </svg>
      </button>
      <button class="control-btn" id="down">
        <svg viewBox="0 0 24 24">
          <path fill="currentColor" d="M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z" transform="rotate(-90 12 12)"/>
        </svg>
      </button>
    </div>
    <div class="control-column" style="margin-right: 20px;">
      <button class="control-btn" id="right">
        <svg viewBox="0 0 24 24">
          <path fill="currentColor" d="M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z"/>
        </svg>
      </button>
      <button class="control-btn" id="rotate">
        <svg viewBox="0 0 24 24">
          <path fill="currentColor" d="M12 6v3l4-4-4-4v3c-4.42 0-8 3.58-8 8 0 1.57.46 3.03 1.24 4.26L6.7 14.8c-.45-.83-.7-1.79-.7-2.8 0-3.31 2.69-6 6-6zm6.76 1.74L17.3 9.2c.44.84.7 1.79.7 2.8 0 3.31-2.69 6-6 6v-3l-4 4 4 4v-3c4.42 0 8-3.58 8-8 0-1.57-.46-3.03-1.24-4.26z"/>
        </svg>
      </button>
    </div>
  </div>
  <div id="instructions">
    <h2>How to Play</h2>
    <p><strong>Keyboard Controls:</strong></p>
    <p>&#x2190; - Move Left</p>
    <p>&#x2192; - Move Right</p>
    <p>&#x2191; - Rotate Piece</p>
    <p>&#x2193; - Move Down Faster</p>
    <p><strong>Mobile Controls:</strong></p>
    <p>Use the on-screen buttons to control the game.</p>
  </div>
  <script type="module">const gameWidth = 10;
const gameHeight = 20;
let gameGrid = Array.from({
  length: gameHeight
}, () => Array(gameWidth).fill(0));
let piece = null;
let pieceX = 0;
let pieceY = 0;
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const cellSize = 30;
canvas.width = gameWidth * cellSize;
canvas.height = gameHeight * cellSize;
function drawCell(x, y, char, isFalling = false) {
  ctx.fillStyle = '#000';
  ctx.fillRect(x * cellSize, y * cellSize, cellSize - 1, cellSize - 1);
  ctx.fillStyle = '#fff';
  ctx.font = `${cellSize - 4}px monospace`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(char, x * cellSize + cellSize / 2, y * cellSize + cellSize / 2);
}
function drawEmptyCell(x, y) {
  ctx.fillStyle = 'rgba(0,0,0,0.7)';
  ctx.fillRect(x * cellSize, y * cellSize, cellSize - 1, cellSize - 1);
  ctx.fillStyle = '#444';
  ctx.font = `${cellSize - 4}px monospace`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('â–’', x * cellSize + cellSize / 2, y * cellSize + cellSize / 2);
}
const shapes = [[[1, 1, 1, 1]], [[1, 1], [1, 1]], [[0, 1, 0], [1, 1, 1]], [[1, 0, 0], [1, 1, 1]], [[0, 0, 1], [1, 1, 1]], [[0, 1, 1], [1, 1, 0]], [[1, 1, 0], [0, 1, 1]]];
const audioContext = new (window.AudioContext || window.webkitAudioContext)();
const bgmTracks = ["http://www.yazooy.com/Resources/MP3/AsciiTetris/JazzPiano1.mp3", "http://www.yazooy.com/Resources/MP3/AsciiTetris/JazzPiano2.mp3", "http://www.yazooy.com/Resources/MP3/AsciiTetris/JazzPiano3.mp3", "http://www.yazooy.com/Resources/MP3/AsciiTetris/JazzPiano4.mp3", "http://www.yazooy.com/Resources/MP3/AsciiTetris/JazzPiano5.mp3", "http://www.yazooy.com/Resources/MP3/AsciiTetris/JazzPiano6.mp3", "http://www.yazooy.com/Resources/MP3/AsciiTetris/JazzPianoChromaticism1.mp3", "http://www.yazooy.com/Resources/MP3/AsciiTetris/JazzPianoChromaticism2.mp3"];
let bgmIndex = 0;
let bgmAudio = null;
function playBGM() {
  if (bgmAudio) {
    bgmAudio.pause();
    bgmAudio = null;
  }
  const audioUrl = bgmTracks[bgmIndex];
  bgmAudio = new Audio(audioUrl);
  bgmAudio.addEventListener('error', e => {
    console.error('Audio error:', e);
    bgmIndex = (bgmIndex + 1) % bgmTracks.length;
    setTimeout(playBGM, 1000);
  });
  bgmAudio.loop = true;
  bgmAudio.volume = 0.3;
  bgmAudio.play().catch(error => {
    console.error('Audio playback failed:', error);
    bgmIndex = (bgmIndex + 1) % bgmTracks.length;
    setTimeout(playBGM, 1000);
  });
  bgmIndex = (bgmIndex + 1) % bgmTracks.length;
}
function playSound(frequency, duration = 0.1) {
  const oscillator = audioContext.createOscillator();
  const gainNode = audioContext.createGain();
  oscillator.type = 'square';
  oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
  gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
  oscillator.connect(gainNode);
  gainNode.connect(audioContext.destination);
  oscillator.start();
  gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
  oscillator.stop(audioContext.currentTime + duration);
}
function showGameOver() {
  const gameOver = document.getElementById('game-over');
  gameOver.style.display = 'block';
  setTimeout(() => {
    gameOver.style.display = 'none';
  }, 2000);
  playSound(440, 0.5);
}
function spawnPiece() {
  piece = shapes[Math.floor(Math.random() * shapes.length)];
  pieceX = Math.floor((gameWidth - piece[0].length) / 2);
  pieceY = 0;
  if (collision()) {
    showGameOver();
    resetGame();
  }
}
function collision() {
  for (let y = 0; y < piece.length; y++) {
    for (let x = 0; x < piece[y].length; x++) {
      if (piece[y][x] && (pieceY + y >= gameHeight || pieceX + x < 0 || pieceX + x >= gameWidth || (gameGrid[pieceY + y] && gameGrid[pieceY + y][pieceX + x]) !== 0)) {
        return true;
      }
    }
  }
  return false;
}
function mergePiece() {
  for (let y = 0; y < piece.length; y++) {
    for (let x = 0; x < piece[y].length; x++) {
      if (piece[y][x]) {
        gameGrid[pieceY + y][pieceX + x] = 1;
      }
    }
  }
}
function clearLines() {
  gameGrid = gameGrid.filter(row => row.some(cell => cell === 0));
  while (gameGrid.length < gameHeight) {
    gameGrid.unshift(Array(gameWidth).fill(0));
  }
}
function resetGame() {
  gameGrid = Array.from({
    length: gameHeight
  }, () => Array(gameWidth).fill(0));
  spawnPiece();
}
function rotatePiece() {
  const newPiece = piece[0].map((_, y) => piece.map(row => row[y]).reverse());
  const oldPiece = piece;
  piece = newPiece;
  if (collision()) {
    piece = oldPiece;
  }
}
function updateGame() {
  if (piece === null) spawnPiece();
  pieceY++;
  if (collision()) {
    pieceY--;
    mergePiece();
    clearLines();
    spawnPiece();
  }
  renderGame();
}
function renderGame() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  const asciiChars = ['#', '@', '%', '&', '*'];
  for (let y = 0; y < gameHeight; y++) {
    for (let x = 0; x < gameWidth; x++) {
      if (gameGrid[y][x]) {
        drawCell(x, y, asciiChars[Math.floor(Math.random() * asciiChars.length)], false);
      } else {
        drawEmptyCell(x, y);
      }
    }
  }
  if (piece) {
    for (let y = 0; y < piece.length; y++) {
      for (let x = 0; x < piece[y].length; x++) {
        if (piece[y][x]) {
          drawCell(pieceX + x, pieceY + y, asciiChars[Math.floor(Math.random() * asciiChars.length)], true);
        }
      }
    }
  }
}
document.addEventListener('keydown', e => {
  if (e.key === 'ArrowLeft' && pieceX > 0) {
    pieceX--;
    if (collision()) pieceX++;else playSound(220);
  }
  if (e.key === 'ArrowRight' && pieceX + piece[0].length < gameWidth) {
    pieceX++;
    if (collision()) pieceX--;else playSound(440);
  }
  if (e.key === 'ArrowDown') {
    updateGame();
    playSound(880);
  }
  if (e.key === 'ArrowUp') {
    rotatePiece();
    playSound(660);
  }
  renderGame();
});
const setupButton = (id, action) => {
  const btn = document.getElementById(id);
  btn.addEventListener('touchstart', e => {
    e.preventDefault();
    action();
    renderGame();
  });
};
setupButton('left', () => {
  if (pieceX > 0) {
    pieceX--;
    if (collision()) pieceX++;else playSound(220);
  }
});
setupButton('right', () => {
  if (pieceX + piece[0].length < gameWidth) {
    pieceX++;
    if (collision()) pieceX--;else playSound(440);
  }
});
setupButton('rotate', () => {
  rotatePiece();
  playSound(660);
});
setupButton('down', () => {
  updateGame();
  playSound(880);
});
setInterval(updateGame, 500);
resetGame();
playBGM();</script>
</body>
</html>